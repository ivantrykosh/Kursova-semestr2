#include "Functional.h"

//// Конструктор за умовчуванням
//System_of_equations::System_of_equations()
//{
//}
//
//// Встановлюємо точність обчислень
//void System_of_equations::set_epsylon(double eps) // "eps" - точність обчислень
//{
//	this->eps = eps;
//}
//
//// Метод для обчислення степеня "y" для числа "x"
//double System_of_equations::mathpow(double x, double y) // "х" - число, "у" - степінь
//{
//	double result = 0.0; // Результат піднесення
//
//	// Якщо "х" більший за 0, то просто підносимо "х" до степеня "у"
//	if (x > 0)
//	{
//		result = pow(x, y);
//	}
//
//	// Якщо "х" = 0, то оброблюємо наступні ситуації
//	else if (x == 0)
//	{
//		// Якщо "у" > 0, то результат піднесення = 0
//		if (y > 0)
//		{
//			result = 0;
//		}
//
//		// Якщо "у" < 0, то результат невизначений і виводимо помилку
//		else if (y < 0)
//		{
//			throw "Результат не знайдено. \nПомилка: піднесення нуля до від'ємного степеня";
//		}
//
//		// Інакше результат = 1 (0 в степені 0 = 1)
//		else
//		{
//			result = 1;
//		}
//	}
//
//	// Якщо "у" - ціле від'ємне число, то ми оброблюємо наступні умови 
//	else if (y == (long long)y)
//	{
//		// Якщо "у" - парне число, то результат буде додатнім
//		if ((int)y % 2 == 0)
//		{
//			result = pow(-x, y); // Для уникнення помилки зробимо "х" додатнім (На результат це не впливає)
//		}
//
//		// Інакше результат буде від'ємним
//		else
//		{
//			result = -pow(-x, y); // Для уникнення помилки зробимо "х" додатнім (Але результат буде від'ємним)
//		}
//	}
//
//	// Інакше результат невизначений і виводимо помилку
//	else
//	{
//		throw "Результат не знайдено. \nПомилка: піднесення до дробового степеня від'ємного числа";
//	}
//
//	return result; // Повертаємо результат обчислень
//}
//
//// Метод для обчислення tg(x)
//double System_of_equations::tangens(double x) // "х" - аргумент функції tg
//{
//	double result = 0.0; // Результат обчислення
//
//	// Якщо cos(x) = 0, то результат невизначений і виводимо помилку
//	if (cos(x) == 0)
//	{
//		throw "Результат не знайдено. \nПомилка: tg(pi/2) не визначений";
//	}
//
//	// Інакше результат визначений і обчислюємо його
//	else
//	{
//		result = tan(x);
//	}
//
//	return result; // Повертаємо результат обчислень
//}
//
//// Метод для обчислення ctg(x)
//double System_of_equations::cotangens(double x) // "х" - аргумент функції ctg
//{
//	double result = 0.0; // Результат обчислень
//
//	// Якщо sin(x) = 0, то результат невизначений і виводимо помилку
//	if (sin(x) == 0)
//	{
//		throw "Результат не знайдено. \nПомилка: ctg(0) не визначений";
//	}
//
//	// Інакше результат визначений і обчислюємо його
//	else
//	{
//		result = cos(x) / sin(x);
//	}
//
//	return result; // Повертаємо результат обчислень
//}
//
//// Метод для обчислення log(x) за основою "base"
//double System_of_equations::logarithm(double base, double x) // "base" - основа логарифма, "x" - аргумент функції log
//{
//	double result = 0.0; // Результат обчислення
//
//	// Якщо основа логарифма > 0 та не дорівнює 1 і "х" > 0, то логарифм визначений і можна обчислити результат
//	if (base > 0 && base != 1 && x > 0)
//	{
//		result = log(x) / log(base); // Використаємо властивість логарифма
//	}
//
//	// Інакше логарифм невизначений і виводимо помилку
//	else
//	{
//		throw "Результат не знайдено. \nПомилка: логарифм обчислити неможливо (не виконуються умови для логарифма)";
//	}
//
//	return result; // Повертаємо результат обчислень
//}
//
//// Метод для обчислення частинних похідних у точці (х, у)
//void System_of_equations::Matrix_W(double x, double y, double* p) // (х, у) - точка, р - вихідна матриця з частинними похідними
//{
//	// Значення функцій в точці (х, у)
//	double x0y0[2];
//	values_of_equations(x, y, &x0y0[0]);
//
//	// Значення функцій в точці (х+h, у), де h - крок (h = eps*0.1)
//	double x1y0[2];
//	values_of_equations(x + eps * 0.1, y, &x1y0[0]);
//
//	// Значення функцій в точці (х, у+h), де h - крок (h = eps*0.1)
//	double x0y1[2];
//	values_of_equations(x, y + eps * 0.1, &x0y1[0]);
//
//	// Заповнюємо матрицю частинними похідними
//	*(p) = (x1y0[0] - x0y0[0]) / (eps * 0.1);
//	*(p + 1) = (x0y1[0] - x0y0[0]) / (eps * 0.1);
//	*(p + 2) = (x1y0[1] - x0y0[1]) / (eps * 0.1);
//	*(p + 3) = (x0y1[1] - x0y0[1]) / (eps * 0.1);
//}
//
//// Метод Ньютона
//vector<vector<double>> System_of_equations::newton(double &x01, double &y01) // (х01, у01) - приближення
//{
//	bool flag = true; // Для виходу із циклу
//	double deltax1 = +INFINITY, deltay1 = +INFINITY; // Для передчасного завершення циклу
//	int i = 1; // Лічильник для передчасного завершення циклу
//	vector<vector<double>> values{ {x01, y01} }; // Масив приближень (х, у)
//
//	// Знаходимо (якщо можливо) розв'язок рівняння
//	do
//	{
//		// Оброблюємо помилки
//		try
//		{
//			double W[2][2]; // Матриця частинних похідних (Матриця Якобі в точці (х, у))
//			Matrix_W(x01, y01, &W[0][0]);  // Знаходимо матрицю Якобі
//			double F[2]; // Масив значень функцій в точці (х, у) із знаком "-"
//			values_of_equations(x01, y01, &F[0]); // Масив F(x,y)
//			F[0] = -F[0]; // Змінюємо знак
//			F[1] = -F[1]; // Змінюємо знак
//			double detW = W[0][0] * W[1][1] - W[0][1] * W[1][0]; // Визначник матриці Якобі
//
//			// Визначник не повинен дорівнювати 0, інакше виводимо помилку
//			if (detW == 0)
//			{
//				throw "Результат не знайдено. \nПомилка: визначник матриці Якобі = 0";
//			}
//
//			double W_Ob[2][2] = { {W[1][1] / detW, -W[0][1] / detW}, // Матриця, обернена до матриці Якобі
//								  {-W[1][0] / detW, W[0][0] / detW} };
//			double deltax = F[0] * W_Ob[0][0] + F[1] * W_Ob[0][1]; // Поправка для х
//			double deltay = F[0] * W_Ob[1][0] + F[1] * W_Ob[1][1]; // Поправка для у
//
//			// Якщо ітерація кратна тисячі, то зберігаємо поточні поправки
//			if (i % 100000 == 0)
//			{
//				// Якщо поправки не змінюються через 1000 ітерацій, то виводимо помилку
//				if (fabs(deltax) >= fabs(deltax1) && fabs(deltay) >= fabs(deltay1))
//				{
//					throw "Результат не знайдено. \nСистема не сходиться";
//				}
//				deltax1 = deltax;
//				deltay1 = deltay;
//			}
//
//			// Інакше збільшуємо лічильник ітерацій
//			else
//			{
//				i++;
//			}
//
//			x01 = x01 + deltax; // Знаходимо наступний х
//			y01 = y01 + deltay; // Знаходимо наступний у
//			values.push_back({ x01, y01 }); // Зберігаємо поточне приближення
//
//			// Якщо досягли потрібної точності, то завершуємо цикл
//			if (fabs(deltax) <= eps && fabs(deltay) <= eps)
//			{
//				flag = false;
//			}
//		}
//		// Оброка помилок
//		catch (const char* e)
//		{
//			throw e; // Виходимо з методу та передаємо текст помилки в головний метод
//		}
//	} while (flag);
//
//	return values; // Повертаємо масив приближень
//}
//
//// Метод січних
//vector<vector<double>> System_of_equations::sichna(double &x01, double &y01) // (х01, у01) - приближення
//{
//	bool flag = true; // Для виходу із циклу
//	double deltax1 = +INFINITY, deltay1 = +INFINITY;  // Для передчасного завершення циклу
//	int i = 1; // Лічильник для передчасного завершення циклу
//	vector<vector<double>> values{ {x01, y01} }; // Масив приближень (х, у)
//	double A[2][2]; // Апроксимована матриця Якобі
//	Matrix_W(x01, y01, &A[0][0]); // Початкова матриця = матриці Якобі
//
//	// Знаходимо (якщо можливо) розв'язок рівняння
//	do
//	{
//		// Оброблюємо помилки
//		try
//		{
//			double F[2]; // Масив значень функцій в точці (х, у) із знаком "-"
//			values_of_equations(x01, y01, &F[0]); // Масив F(x,y)
//			F[0] = -F[0]; // Змінюємо знак
//			F[1] = -F[1]; // Змінюємо знак
//			double detA = A[0][0] * A[1][1] - A[0][1] * A[1][0]; // Визначник матриці А
//
//			// Визначник не повинен дорівнювати 0, інакше виводимо помилку
//			if (detA == 0)
//			{
//				throw "Результат не знайдено. \nПомилка: визначник апроксимованої матриці Якобі = 0";
//			}
//
//			double A_Ob[2][2] = { {A[1][1] / detA, -A[0][1] / detA}, // Матриця, обернена до матриці А
//								  {-A[1][0] / detA, A[0][0] / detA} };
//			double s[2] = { F[0] * A_Ob[0][0] + F[1] * A_Ob[0][1],  F[0] * A_Ob[1][0] + F[1] * A_Ob[1][1] }; // Поправка для х та у
//			
//			// Якщо ітерація кратна тисячі, то зберігаємо поточні поправки
//			if (i % 100000 == 0)
//			{
//				// Якщо поправки не змінюються через 1000 ітерацій, то виводимо помилку
//				if (fabs(s[0]) >= fabs(deltax1) && fabs(s[1]) >= fabs(deltay1))
//				{
//					throw "Результат не знайдено. \nСистема не сходиться";
//				}
//				deltax1 = s[0];
//				deltay1 = s[1];
//			}
//
//			// Інакше збільшуємо лічильник ітерацій
//			else
//			{
//				i++;
//			}
//
//			x01 = x01 + s[0]; // Знаходимо наступний х
//			y01 = y01 + s[1]; // Знаходимо наступний у
//			values.push_back({ x01, y01 }); // Зберігаємо поточне приближення
//
//			// Якщо досягли потрібної точності, то завершуємо цикл
//			if (fabs(s[0]) <= eps && fabs(s[1]) <= eps)
//			{
//				flag = false;
//			}
//
//			//Інакше
//			else
//			{
//				double F1[2]; // Масив значень функцій у нових точках
//				values_of_equations(x01, y01, &F1[0]); // Нові значення
//				double y[2] = { F1[0] + F[0], F1[1] + F[1] }; // Різниця між новими та старими значеннями (F1 - (-F0))
//				double st_s0 = s[0] * s[0] + s[1] * s[1]; // Скалярний добуток матриці з поправками
//				
//				// Якщо скалярний добуток матриці з поправками = 0, то виводимо помилку
//				if (st_s0 == 0)
//				{
//					throw "Результат не знайдено. \nПомилка: ділення на 0";
//				}
//
//				double yA0_s0[2] = { y[0] - A[0][0] * s[0] - A[0][1] * s[1], y[1] - A[1][0] * s[0] - A[1][1] * s[1] }; // Різниця матриці у та добутку матриць А та s
//
//				// Ініціалізуємо нові значення матриці А
//				A[0][0] = A[0][0] + yA0_s0[0] * s[0] / st_s0;
//				A[0][1] = A[0][1] + yA0_s0[0] * s[1] / st_s0;
//				A[1][0] = A[1][0] + yA0_s0[1] * s[0] / st_s0;
//				A[1][1] = A[1][1] + yA0_s0[1] * s[1] / st_s0;
//			}
//		}
//		// Оброка помилок
//		catch (const char* e)
//		{
//			throw e; // Виходимо з методу та передаємо текст помилки в головний метод
//		}
//	} while (flag);
//	
//	return values; // Повертаємо масив приближень
//}
//
//// Конструктор для ініціалізації коефіцієнтів (a1, b1, a2, b2), вільних членів (c1, c2) та степенів "х" (n1, n3) й "y" (n2, n4) системи алгебраїчних рівнянь
//Algebraic_equation::Algebraic_equation(double a1, double b1, double a2, double b2, double c1, double c2, double n1, double n2, double n3, double n4) : System_of_equations::System_of_equations()
//{
//	this->a1 = a1;
//	this->b1 = b1;
//	this->a2 = a2;
//	this->b2 = b2;
//	this->c1 = c1;
//	this->c2 = c2;
//	this->n1 = n1;
//	this->n2 = n2;
//	this->n3 = n3;
//	this->n4 = n4;
//}
//
//// Знаходимо значення алгебраїчних функцій у точці (х, у)
//void Algebraic_equation::values_of_equations(double x, double y, double* p) // (х, у) - точка, р - покажчик на масив значень
//{
//	*(p) = a1 * mathpow(x, n1) + b1 * mathpow(y, n2) - c1; // Знаходимо перше значення функції
//	*(p + 1) = a2 * mathpow(x, n3) + b2 * mathpow(y, n4) - c2; // Знаходимо друге значення функції
//}
//
//// Конструктор для ініціалізації коефіцієнтів (a1, b1, a2, b2), вільних членів (c1, c2) системи тригонометричних рівнянь
//Trigonometric_equation::Trigonometric_equation(double a1, double b1, double a2, double b2, double c1, double c2) : System_of_equations::System_of_equations()
//{
//	this->a1 = a1;
//	this->b1 = b1;
//	this->a2 = a2;
//	this->b2 = b2;
//	this->c1 = c1;
//	this->c2 = c2;
//}
//
//// Знаходимо значення тригонометричних функцій у точці (х, у)
//void Trigonometric_equation::values_of_equations(double x, double y, double* p) // (х, у) - точка, р - покажчик на масив значень
//{
//	*(p) = a1 * sin(x) + b1 * cos(y) - c1; // Знаходимо перше значення функції
//	*(p + 1) = a2 * tangens(x) + b2 * cotangens(y) - c2; // Знаходимо друге значення функції
//}
//
//// Конструктор для ініціалізації коефіцієнтів (a1, b1, a2, b2), вільних членів (c1, c2) та основ логарифмів (n1, n2) системи трансцендентних рівнянь
//Transcendental_equation::Transcendental_equation(double a1, double b1, double a2, double b2, double c1, double c2, double n1, double n2) : System_of_equations::System_of_equations()
//{
//	this->a1 = a1;
//	this->b1 = b1;
//	this->a2 = a2;
//	this->b2 = b2;
//	this->c1 = c1;
//	this->c2 = c2;
//	this->n1 = n1;
//	this->n2 = n2;
//}
//
//// Знаходимо значення тригонометричних функцій у точці (х, у)
//void Transcendental_equation::values_of_equations(double x, double y, double* p) // (х, у) - точка, р - покажчик на масив значень
//{
//	*(p) = a1 * mathpow(M_E, x) + b1 * mathpow(M_E, -y) - c1; // Знаходимо перше значення функції
//	*(p + 1) = a2 * logarithm(n1, x) + b2 * logarithm(n2, y) - c2; // Знаходимо друге значення функції
//}