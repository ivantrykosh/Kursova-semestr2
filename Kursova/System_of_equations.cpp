#include "System_of_equations.h"

// Конструктор за умовчуванням
System_of_equations::System_of_equations()
{
}

// Встановлюємо точність обчислень
void System_of_equations::set_epsylon(double eps) // "eps" - точність обчислень
{
	this->eps = eps;
}

// Метод для обчислення степеня "y" для числа "x"
double System_of_equations::mathpow(double x, double y) // "х" - число, "у" - степінь
{
	double result = 0.0; // Результат піднесення

	// Якщо "х" більший за 0, то просто підносимо "х" до степеня "у"
	if (x > 0)
	{
		result = pow(x, y);
	}

	// Якщо "х" = 0, то оброблюємо наступні ситуації
	else if (x == 0)
	{
		// Якщо "у" > 0, то результат піднесення = 0
		if (y > 0)
		{
			result = 0;
		}

		// Якщо "у" < 0, то результат невизначений і виводимо помилку
		else if (y < 0)
		{
			throw "Результат не знайдено. \nПомилка: піднесення нуля до від'ємного степеня";
		}

		// Інакше результат = 1 (0 в степені 0 = 1)
		else
		{
			result = 1;
		}
	}

	// Якщо "у" - ціле від'ємне число, то ми оброблюємо наступні умови 
	else if (y == (long long)y)
	{
		// Якщо "у" - парне число, то результат буде додатнім
		if ((int)y % 2 == 0)
		{
			result = pow(-x, y); // Для уникнення помилки зробимо "х" додатнім (На результат це не впливає)
		}

		// Інакше результат буде від'ємним
		else
		{
			result = -pow(-x, y); // Для уникнення помилки зробимо "х" додатнім (Але результат буде від'ємним)
		}
	}

	// Інакше результат невизначений і виводимо помилку
	else
	{
		throw "Результат не знайдено. \nПомилка: піднесення до дробового степеня від'ємного числа";
	}

	return result; // Повертаємо результат обчислень
}

// Метод для обчислення tg(x)
double System_of_equations::tangens(double x) // "х" - аргумент функції tg
{
	double result = 0.0; // Результат обчислення

	// Якщо cos(x) = 0, то результат невизначений і виводимо помилку
	if (cos(x) == 0)
	{
		throw "Результат не знайдено. \nПомилка: tg(pi/2) не визначений";
	}

	// Інакше результат визначений і обчислюємо його
	else
	{
		result = tan(x);
	}

	return result; // Повертаємо результат обчислень
}

// Метод для обчислення ctg(x)
double System_of_equations::cotangens(double x) // "х" - аргумент функції ctg
{
	double result = 0.0; // Результат обчислень

	// Якщо sin(x) = 0, то результат невизначений і виводимо помилку
	if (sin(x) == 0)
	{
		throw "Результат не знайдено. \nПомилка: ctg(0) не визначений";
	}

	// Інакше результат визначений і обчислюємо його
	else
	{
		result = cos(x) / sin(x);
	}

	return result; // Повертаємо результат обчислень
}

// Метод для обчислення log(x) за основою "base"
double System_of_equations::logarithm(double base, double x) // "base" - основа логарифма, "x" - аргумент функції log
{
	double result = 0.0; // Результат обчислення

	// Якщо основа логарифма > 0 та не дорівнює 1 і "х" > 0, то логарифм визначений і можна обчислити результат
	if (base > 0 && base != 1 && x > 0)
	{
		result = log(x) / log(base); // Використаємо властивість логарифма
	}

	// Інакше логарифм невизначений і виводимо помилку
	else
	{
		throw "Результат не знайдено. \nПомилка: логарифм обчислити неможливо (не виконуються умови для логарифма)";
	}

	return result; // Повертаємо результат обчислень
}

// Метод для обчислення частинних похідних у точці (х, у)
void System_of_equations::Matrix_W(double x, double y, double* p) // (х, у) - точка, р - вихідна матриця з частинними похідними
{
	// Значення функцій в точці (х, у)
	double x0y0[2];
	values_of_equations(x, y, &x0y0[0]);

	// Значення функцій в точці (х+h, у), де h - крок (h = eps*0.1)
	double x1y0[2];
	values_of_equations(x + eps * 0.1, y, &x1y0[0]);

	// Значення функцій в точці (х, у+h), де h - крок (h = eps*0.1)
	double x0y1[2];
	values_of_equations(x, y + eps * 0.1, &x0y1[0]);

	// Заповнюємо матрицю частинними похідними
	*(p) = (x1y0[0] - x0y0[0]) / (eps * 0.1);
	*(p + 1) = (x0y1[0] - x0y0[0]) / (eps * 0.1);
	*(p + 2) = (x1y0[1] - x0y0[1]) / (eps * 0.1);
	*(p + 3) = (x0y1[1] - x0y0[1]) / (eps * 0.1);
}

// Метод Ньютона
vector<vector<double>> System_of_equations::newton(double& x01, double& y01) // (х01, у01) - приближення
{
	bool flag = true; // Для виходу із циклу
	double deltax1 = +INFINITY, deltay1 = +INFINITY; // Для передчасного завершення циклу
	int i = 1; // Лічильник для передчасного завершення циклу
	vector<vector<double>> values{ {x01, y01} }; // Масив приближень (х, у)
	bool flag2 = true;
	do
	{
		try
		{
			double W[2][2]; // Матриця частинних похідних (Матриця Якобі в точці (х, у))
			Matrix_W(x01, y01, &W[0][0]);  // Знаходимо матрицю Якобі
			double F[2]; // Масив значень функцій в точці (х, у) із знаком "-"
			values_of_equations(x01, y01, &F[0]); // Масив F(x,y)
			F[0] = -F[0]; // Змінюємо знак
			F[1] = -F[1]; // Змінюємо знак
			double detW = W[0][0] * W[1][1] - W[0][1] * W[1][0]; // Визначник матриці Якобі

			// Визначник не повинен дорівнювати 0, інакше виводимо помилку
			if (detW == 0)
			{
				throw "Результат не знайдено. \nПомилка: визначник матриці Якобі = 0";
			}

			double W_Ob[2][2] = { {W[1][1] / detW, -W[0][1] / detW}, // Матриця, обернена до матриці Якобі
								  {-W[1][0] / detW, W[0][0] / detW} };
			double deltax = F[0] * W_Ob[0][0] + F[1] * W_Ob[0][1]; // Поправка для х
			double deltay = F[0] * W_Ob[1][0] + F[1] * W_Ob[1][1]; // Поправка для у

			// Якщо ітерація кратна тисячі, то зберігаємо поточні поправки
			if (i % 1000 == 0)
			{
				// Якщо поправки не змінюються через 1000 ітерацій, то виводимо помилку
				if (fabs(deltax) >= fabs(deltax1) && fabs(deltay) >= fabs(deltay1))
				{
					throw "Результат не знайдено.";
				}
				deltax1 = deltax;
				deltay1 = deltay;
			}

			// Інакше збільшуємо лічильник ітерацій
			else
			{
				i++;
			}

			x01 = x01 + deltax; // Знаходимо наступний х
			y01 = y01 + deltay; // Знаходимо наступний у
			values.push_back({ x01, y01 }); // Зберігаємо поточне приближення

			if (isnan(x01) || isnan(y01) || isinf(x01) || isinf(y01))
			{
				throw "Результат не знайдено.";
			}

			// Якщо досягли потрібної точності, то завершуємо цикл
			if (fabs(deltax) <= eps && fabs(deltay) <= eps)
			{
				double Values[2];
				values_of_equations(x01, y01, &Values[0]);
				if (fabs(Values[0]) <= eps && fabs(Values[1]) <= eps)
				{
					flag = false;
				}
				else if (flag2)
				{
					flag2 = false;
				}
				else
				{
					throw "Результат не знайдено.";
				}
			}
		}
		catch (const char* e)
		{
			throw e; // Виходимо з методу та передаємо текст помилки в головний метод
		}
	} while (flag);

	return values; // Повертаємо масив приближень
}

// Метод січних
vector<vector<double>> System_of_equations::sichna(double& x01, double& y01) // (х01, у01) - приближення
{
	bool flag = true; // Для виходу із циклу
	double deltax1 = +INFINITY, deltay1 = +INFINITY;  // Для передчасного завершення циклу
	int i = 1; // Лічильник для передчасного завершення циклу
	vector<vector<double>> values{ {x01, y01} }; // Масив приближень (х, у)
	bool flag2 = true;
	double A[2][2]; // Апроксимована матриця Якобі
	Matrix_W(x01, y01, &A[0][0]); // Початкова матриця = матриці Якобі
	
	do
	{
		try
		{
			double F[2]; // Масив значень функцій в точці (х, у) із знаком "-"
			values_of_equations(x01, y01, &F[0]); // Масив F(x,y)
			F[0] = -F[0]; // Змінюємо знак
			F[1] = -F[1]; // Змінюємо знак
			double detA = A[0][0] * A[1][1] - A[0][1] * A[1][0]; // Визначник матриці А

			// Визначник не повинен дорівнювати 0, інакше виводимо помилку
			if (detA == 0)
			{
				throw "Результат не знайдено. \nПомилка: визначник апроксимованої матриці Якобі = 0";
			}

			double A_Ob[2][2] = { {A[1][1] / detA, -A[0][1] / detA}, // Матриця, обернена до матриці А
								  {-A[1][0] / detA, A[0][0] / detA} };
			double s[2] = { F[0] * A_Ob[0][0] + F[1] * A_Ob[0][1],  F[0] * A_Ob[1][0] + F[1] * A_Ob[1][1] }; // Поправка для х та у

			// Якщо ітерація кратна тисячі, то зберігаємо поточні поправки
			if (i % 1000 == 0)
			{
				// Якщо поправки не змінюються через 1000 ітерацій, то виводимо помилку
				if (fabs(s[0]) >= fabs(deltax1) && fabs(s[1]) >= fabs(deltay1))
				{
					throw "Результат не знайдено.";
				}
				deltax1 = s[0];
				deltay1 = s[1];
			}

			// Інакше збільшуємо лічильник ітерацій
			else
			{
				i++;
			}

			x01 = x01 + s[0]; // Знаходимо наступний х
			y01 = y01 + s[1]; // Знаходимо наступний у
			values.push_back({ x01, y01 }); // Зберігаємо поточне приближення

			if (isnan(x01) || isnan(y01) || isinf(x01) || isinf(y01))
			{
				throw "Результат не знайдено.";
			}

			// Якщо досягли потрібної точності, то завершуємо цикл
			if (fabs(s[0]) <= eps && fabs(s[1]) <= eps)
			{
				double Values[2];
				values_of_equations(x01, y01, &Values[0]);
				if (fabs(Values[0]) <= eps && fabs(Values[1]) <= eps)
				{
					flag = false;
				}
				else if (flag2)
				{
					flag2 = false;
				}
				else
				{
					throw "Результат не знайдено.";
				}
			}
			else
			{
				double F1[2]; // Масив значень функцій у нових точках
				values_of_equations(x01, y01, &F1[0]); // Нові значення
				double y[2] = { F1[0] + F[0], F1[1] + F[1] }; // Різниця між новими та старими значеннями (F1 - (-F0))
				double st_s0 = s[0] * s[0] + s[1] * s[1]; // Скалярний добуток матриці з поправками

				// Якщо скалярний добуток матриці з поправками = 0, то виводимо помилку
				if (st_s0 == 0)
				{
					throw "Результат не знайдено. \nПомилка: ділення на 0";
				}

				double yA0_s0[2] = { y[0] - A[0][0] * s[0] - A[0][1] * s[1], y[1] - A[1][0] * s[0] - A[1][1] * s[1] }; // Різниця матриці у та добутку матриць А та s

				// Ініціалізуємо нові значення матриці А
				A[0][0] = A[0][0] + yA0_s0[0] * s[0] / st_s0;
				A[0][1] = A[0][1] + yA0_s0[0] * s[1] / st_s0;
				A[1][0] = A[1][0] + yA0_s0[1] * s[0] / st_s0;
				A[1][1] = A[1][1] + yA0_s0[1] * s[1] / st_s0;
			}
		}
		catch (const char* e)
		{
			throw e; // Виходимо з методу та передаємо текст помилки в головний метод
		}
	} while (flag);

	return values; // Повертаємо масив приближень
}